# 遍历一个集合的所有子集-常用算法思想

遍历一个集合的所有子集的**通用算法思想**可以归结为一句话：

> **“对集合的每个元素，依次决定‘取’或‘不取’。”**

不论用哪种实现手段（位运算、递归、迭代、队列、栈），本质都在做同一件事：**枚举长度为 n 的二叉决策树的所有 2ⁿ 条路径**。下面给出三种**与语言无关的抽象思路**。

## 二进制掩码（Bit-mask）思想

把子集映射成一个 n 位二进制数：

- 第 i 位为 1 → 选取第 i 个元素
- 第 i 位为 0 → 不选第 i 个元素

从 0 数到 2ⁿ−1，即天然枚举了全部 2ⁿ 个子集。

> **关键抽象**：  
> 集合 ↔ n 位二进制 ↔ 0…2ⁿ−1 的整数。

## 回溯 / 深度优先决策树

把每个元素视为一层决策节点：

- 左分支：不放入当前元素
- 右分支：放入当前元素

自顶向下递归或显式栈遍历这棵树，即可按任意顺序产出所有子集。

> **关键抽象**：  
> 路径 = 已做的“取/不取”序列；  
> 叶子节点 = 一个完整子集。

## 增量构造（幂集迭代）

从空集 ∅ 开始，逐元素扫描：

- 将当前元素加入“已有子集的拷贝”
- 把新产生的子集并入结果

每轮元素会使子集数量翻倍，正好对应 2ⁿ 规模。

> **关键抽象**：  
> 第 k 步维护 2ᵏ 个已生成子集；  
> 第 k+1 步复制并扩展得到 2ᵏ⁺¹ 个。

## 总结

**无论二进制、递归、迭代还是队列，都只是“对 n 位取/舍决策”的不同遍历策略；算法核心永远是 2ⁿ 条路径的枚举。**
