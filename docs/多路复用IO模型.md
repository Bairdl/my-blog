# 多路复用 I/O 模型

多路复用模型的核心目标是**使用单个线程监听大量的 I/O 事件**。

当 I/O 事件发生时，将事件对应的处理函数加入事件队列，当线程空闲时，从事件队列中取出事件对应的处理函数并执行。

多路复用 I/O 模型是**工作在操作系统层面的机制**，它通过系统调用（如`select`/`poll`/`epoll`/`kqueue`等）让内核帮助用户程序监控多个 I/O 描述的状态。

> [!NOTE] 文件描述符
> 文件描述符（File Descriptor）是操作系统为每个打开的文件或 I/O 资源（套接字）分配的编号，用于标识该文件或套接字。
> 本质是内核维护的进程级文件描述符表的索引。通过这个索引，进程可以快速找到内核中对应的文件对象（如文件、socket、管道等）。
> 应用程序，通过文件描述符，可以与内核进行通信，进行文件读写、socket 操作、管道操作等。

## 实现原理

1. 内核级监控：
   - 用户程序通过系统调用将多个文件描述符（socket 等）注册到内核的监控列表中。
   - 内核会持续扫描这些描述符，当某个描述符就绪（如数据到达、 可写或者出错）时，内核会通知用户程序。
2. 事件驱动：
   - 用户线程通过阻塞调用（如`epoll_wait`）等待内核通知，此时线程处于休眠状态，不占用 CPU。
   - 当有 I/O 事件就绪时，线程会被唤醒，处理对应的 I/O 操作（如读写数据）。

多路复用 I/O 模型（如 select、poll、epoll、kqueue）的核心思想类似，但底层实现机制不同，主要体现在：

- `select`/`poll`：
  - 轮询机制：内核需要线性扫描所有注册的文件描述符（FD），检查其状态，时间复杂度为 O(n)。
  - 无差别返回所有就绪的 FD，用户程序需遍历处理。
  - 系统调用： `select()`、`poll()`。
- `epoll`（Linux）/`kqueue`（BSD）：
  - 事件驱动：内核通过回调或哈希表等结构仅跟踪活跃的 FD，就绪时直接返回，时间复杂度 O(1)。
  - 系统调用：`epoll_create`、`epoll_ctl`、`epoll_wait`（Linux）或 `kqueue`、`kevent`（BSD）。

总结：

- 所有多路复用模型都依赖内核监控 FD 状态，但高效性差异显著（`epoll`/`kqueue` 优于 `select`/`poll`）。
- 事件驱动是 `epoll`/`kqueue` 的特性，`select`/`poll` 是轮询机制。

## 工作原理

通用流程（注册 → 监听 → 通知）适用于所有多路复用模型，但实现细节不同：

| 步骤 | `select`/`poll`                   | `epoll`/`kqueue`             |
| ---- | --------------------------------- | ---------------------------- |
| 注册 | 每次调用需重新传入所有 FD         | 通过 epoll_ctl 单独增删改 FD |
| 监听 | 阻塞调用，扫描所有 FD             | 阻塞调用，仅监控活跃 FD      |
| 通知 | 返回所有 FD（需遍历判断就绪状态） | 直接返回就绪 FD 列表         |

其优点是**避免了线程切换的开销，实现了 IO 的并发**，但缺点是**无法处理 CPU 密集型任务**。

## 多路复用 vs. 事件驱动

- 多路复用（Multiplexing）：指单线程监控多个 I/O 描述符的技术，涵盖 select/poll/epoll/kqueue 等具体实现。
- 事件驱动（Event-Driven）：指基于事件通知的编程模型（如 epoll/kqueue），内核主动通知就绪事件，无需轮询。
- 关系：
  - 事件驱动是多路复用的一种高效实现方式（如 epoll）。
  - 但多路复用不一定是事件驱动（如 select 是轮询）。

## 事件驱动

**事件驱动**是一种编程模型，其核心思想是：**程序的执行流程由外部事件（如 I/O 操作、用户输入、定时器等）触发，而非主动轮询或顺序控制**。

---

### 核心特点

- **被动响应**：程序不主动检查状态，而是等待事件发生并回调处理。
- **非阻塞**：主线程不会被长时间阻塞，适合高并发场景。
- **异步性**：事件触发和处理可能发生在不同时间点。

---

### 典型应用场景

- **I/O 多路复用**（如 `epoll`、`kqueue`）：监控多个文件描述符，就绪时触发事件。
- **GUI 编程**（如按钮点击、鼠标移动）。
- **服务器框架**（如 Node.js、Nginx）：通过事件循环处理海量连接。

---

### 事件驱动的工作流程

1. **注册事件**：声明程序对哪些事件感兴趣（如“当 Socket 可读时通知我”）。
2. **事件循环**：主线程等待内核/系统通知事件发生（如 `epoll_wait`）。
3. **触发回调**：事件发生时，调用预先注册的处理函数。

---

### 与非事件驱动的对比

| **事件驱动**               | **非事件驱动（轮询）**           |
| -------------------------- | -------------------------------- |
| 被动接收通知（高效）       | 主动轮询检查状态（CPU 浪费）     |
| 适合高并发（如万级连接）   | 适合简单场景（如低并发阻塞 I/O） |
| 典型实现：`epoll`、Node.js | 典型实现：`select`、忙等待循环   |

---

### **总结**

事件驱动通过 **“订阅-通知”机制** 将程序从主动轮询中解放，是高性能、高并发系统的核心设计模式之一。其本质是 **将 I/O 等待时间转化为事件处理时间**，最大化资源利用率。
