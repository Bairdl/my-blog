# Nginx 事件循环：执行逻辑

## 核心答案：事件循环概览

OpenResty 基于 Nginx，其事件循环是其高并发的灵魂。它**不是以“请求”为单位，而是以“事件”为单位**。一个事件循环处理成千上万个连接上发生的各种事件（如可读、可写、超时）。

---

## 1. 事件循环的工作机制：开始与结束

**循环的开始与结束：**

一个完整的事件循环（`ngx_process_events_and_timers` 函数）可以简化为以下流程：

1. **开始：获取并计算时间戳（更新 `ngx_current_msec`）**
    * 循环开始时，会首先调用 `gettimeofday()` 或类似的高性能时间函数，获取当前系统时间（毫秒精度），并更新全局缓存变量 `ngx_current_msec`。**这就是 `ngx.now()` 的数据来源**。所以，**时间戳在每个事件循环开始时更新**，而不是结束时。
    * 计算本轮循环中定时器的最大等待时间（`timer`参数）。

2. **核心：处理事件（`ngx_process_events`）**
    * 调用底层的事件通知机制（如 Linux 下的 `epoll_wait`）。
    * `epoll_wait` 会在此**阻塞等待**，直到以下两种情况之一发生：
        a)  **有事件发生**：一个或多个连接上有数据可读、可写或出现错误。
        b)  **超时**：等待的时间超过了步骤1中计算出的 `timer` 值。
    * 当 `epoll_wait` 返回后，事件模块会遍历所有被触发的事件，为每个事件找到对应的连接（`ngx_connection_t`），并将其放入一个“待处理队列”（`ngx_posted_accept_events` 和 `ngx_posted_events`）中。

3. **收尾：处理“后置”事件（`ngx_event_process_posted`）**
    * **这是真正执行事件处理逻辑的地方**。事件循环会依次处理“待处理队列”中的事件，执行它们对应的回调函数（handler）。
    * 例如，对于一个可读事件，它的 handler 会去读取 socket 上的数据并解析 HTTP 请求。
    * 处理完所有队列里的事件后，本轮事件循环就**结束**了。

4. **特殊处理：定时器事件**
    * 在事件循环的末尾（或特定时机），会检查**红黑树（一种高效的数据结构）** 中所有已经到期的定时器事件。
    * 执行这些到期定时器的回调函数（例如，关闭超时的连接）。

**总结一次循环：**
**开始**（更新时间、计算超时） -> **等待**（`epoll_wait`阻塞） -> **分发**（将就绪事件加入队列） -> **执行**（处理队列中的事件和到期定时器） -> **结束**。

然后，整个过程周而复始，除非 worker 进程收到退出信号。

---

## 2. 新事件添加到当前循环还是下一轮？

这是一个关键问题，答案取决于事件的类型和产生的时机。

**总原则：为了极致的性能，Nginx/OpenResty 会尽量避免不必要的系统调用（如 `epoll_wait` 的唤醒），并优先在本次循环中处理完尽可能多的事件。**

**具体分析：**

1. **网络 I/O 事件（如 `cosocket:receive`）**:
    * 这些事件由操作系统内核管理。当你发起一个异步读操作时，如果数据没有立刻到达，该连接的读事件会被标记为“等待中”，并交由 `epoll` 来监听。这个监听状态的修改（`epoll_ctl`）是立即发生的，但事件的触发（数据到达）和处理**一定是在未来的某一轮事件循环中**。

2. **定时器事件（如 `ngx.timer.at`）**:
    * 当你通过 `ngx.timer.at` 添加一个用户定时器时，它会被立即加入到全局的定时器红黑树中。
    * **它的执行绝对不在当前循环**。定时器检查发生在每轮循环的末尾。只有当当前系统时间 `ngx_current_msec` 大于或等于你设置的延迟时间时，它的回调函数才会被执行。因此，它总是在**未来的某一轮循环**中被触发。

3. **信号量、条件变量等同步原语**:
    * OpenResty 提供了一些同步工具，如 `ngx.semaphore`。
    * 当一个协程在等待信号量（`sem:wait`）时，它会被挂起（yield）。当另一个协程调用 `sem:post` 时，它会唤醒等待的协程。
    * **这个被唤醒的协程通常会被加入到当前运行的“后置事件队列”中**。这意味着，如果 `sem:post` 发生在某次事件循环的“执行”阶段（例如，在一个 cosocket 的回调中），那么被唤醒的协程**很可能就在本轮循环中被继续执行**，而不是等到下一轮。这减少了延迟，提高了效率。

4. **通过 `ngx.thread.spawn` 创建的新“轻线程”**:
    * 新创建的“轻线程”不会立即执行。它会被放入一个就绪队列。**在当前协程 yield 或结束时，调度器会从就绪队列中取出下一个就绪的“轻线程”来执行**。这个执行也发生在**当前事件循环内**。

**结论：**

* **网络 I/O**：未来循环。
* **定时器**：未来循环。
* **信号量唤醒、新轻线程**：**通常在当前循环内**立即得到调度和执行，这是 OpenResty 高性能协作式并发的重要体现。

---

## 3. `ngx.now()` 的更新时间

正如在第一部分中详细说明的，**`ngx.now()` 返回的缓存时间在每个事件循环的开始时更新**。

* **原因**：`gettimeofday()` 系统调用虽然不重，但在每秒处理数十万次请求的场景下，频繁调用它仍然是一笔不小的开销。因此，Nginx 选择在每个事件循环开始时只调用一次，然后将这个时间缓存起来（`ngx_current_msec`），供整个循环中的所有模块、请求和定时器使用。
* **这意味着**：在一个事件循环内部，无论你在哪个阶段、哪个协程中调用 `ngx.now()`，它返回的值都是**相同的**。它不会像 `ngx.req.start_time()` 那样精确到单个请求的开始时间。
* **精度**：它提供的是毫秒级精度，对于 Web 服务器来说完全足够。

## 总结

| 问题 | 答案 |
| :--- | :--- |
| **循环开始** | 更新时间戳 (`ngx_current_msec`)，计算定时器超时。 |
| **循环结束** | 处理完后置事件队列中的事件和到期定时器。 |
| **网络 I/O** | 监听立即生效，处理在**未来**的事件循环中。 |
| **用户定时器** | 添加立即生效，执行在**未来**的事件循环中。 |
| **信号量唤醒** | **通常在当前**事件循环内立即调度执行。 |
| **`ngx.now()` 更新时间** | **每个事件循环开始时**更新一次，循环内保持不变。 |

这种精巧的设计使得 OpenResty/Nginx 能够用极少的资源来高效地处理海量的并发连接，这也是其高性能的基石。
