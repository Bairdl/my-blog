# 模块设计：并发

在设计一个有可能并发的模块时，确实有一套系统性的思考步骤和最佳实践。这不仅仅是编写代码，更是一种设计哲学。

以下是设计并发模块的步骤和需要注意的关键点：

---

## 设计步骤（思考流程）

### 第一步：分析并定义状态（State）

这是最重要的一步。问自己：

1. **我的模块需要维护状态吗？** 比如配置、计数器、连接池、会话列表等。
2. **这些状态需要被并发访问吗？** 即是否会被多个Goroutine同时读写。

**决策**：

- **如果无状态**：恭喜你，设计变得非常简单！你可以安全地在多个Goroutine中使用该模块的所有功能。例如，一个纯计算的工具类。
- **如果有状态**：这是常态，也是复杂性的来源。你需要进入下一步。

### 第二步：选择状态管理策略

对于有状态的模块，你有两个核心选择：

| 策略 | 描述 | 适用场景 |
| :--- | :--- | :--- |
| **1. 通过通信共享内存 (Channel)** | 将状态封装在一个**单一的Goroutine**中。其他Goroutine通过向这个Goroutine发送消息（通过Channel）来查询或修改状态。 | 状态复杂、操作多样、需要保证操作顺序的场景。例如 `SessionManager`。 |
| **2. 通过同步原语共享内存 (Mutex)** | 状态被一个**互斥锁**（如 `sync.Mutex` 或 `sync.RWMutex`）保护。所有访问状态的Goroutine必须先获取锁。 | 状态简单、访问模式简单（特别是读多写少）、性能要求极高的场景。例如一个简单的缓存。 |

**如何选择**：

- 默认优先考虑 **策略1（Channel）**。它更符合Go哲学，能更好地避免竞态条件，代码往往更清晰。
- 只有在性能测试证明锁成为瓶颈时，或者状态非常简单时，才使用 **策略2（Mutex）**。

### 第三步：设计接口（API）

你的模块如何被其他Goroutine使用？设计一个**线程安全的API**。

- **如果采用策略1（Channel）**：
  - 你的模块会有一个“管理循环”Goroutine。
  - 对外提供的方法通常是**向内部Channel发送一条消息**，并可能需要等待一个响应Channel。
  - 例如：`func (m *Manager) GetSession(id ID) (*Session, error)`

- **如果采用策略2（Mutex）**：
  - 你的模块的**每一个公开方法**都必须在开始处获取锁，并用 `defer` 释放锁。
  - 例如：

        ```go
        func (c *Cache) Get(key string) (interface{}, bool) {
            c.mu.RLock()         // 获取读锁
            defer c.mu.RUnlock() // 方法返回时释放锁
            // ... 读取操作 ...
        }
        ```

### 第四步：规划生命周期（启动与关闭）

并发模块必须能被优雅地启动和关闭。

1. **启动**：通常提供一个 `Start(ctx context.Context)` 方法，在里面启动必要的后台Goroutine。
2. **关闭**：提供一个 `Shutdown(ctx context.Context) error` 方法。
    - 监听传入的 `ctx.Done()` 信号。
    - 关闭内部Channel、通知后台Goroutine退出。
    - 使用 `sync.WaitGroup` 等待所有后台Goroutine结束。
    - 尊重传入的Context超时。

### 第五步：考虑可观察性（Observability）

并发代码更难调试。必须在设计阶段就加入观测点。

- **metrics**：使用Prometheus等库暴露指标，如：Goroutine数量、Channel长度、处理延迟、错误计数等。
- **Tracing**：在分布式请求链中传递Trace ID，方便追踪一个请求 across多个Goroutine。
- **Context**：利用Context传递请求范围的值（如Request ID）。

---

## 需要注意的关键点（陷阱与最佳实践）

1. **绝不暴露内部状态**：永远不要将内部的数据结构（如slice、map）或Channel直接返回给调用者。这相当于放弃了控制权。应该返回数据的副本或通过接口提供访问方式。

2. **谨慎选择Channel类型**：
    - **无缓冲Channel**：用于强同步通信，保证发送和接收方同时就绪。
    - **有缓冲Channel**：用于解耦和削峰填谷，避免瞬时压力导致阻塞。**缓冲区大小需要谨慎设置**。

3. **总是使用 `context.Context`**：任何可能阻塞的操作（I/O、Channel操作）都应该接受一个 `Context` 参数，以便可以被取消和设置超时。

4. **避免Goroutine泄漏**：
    - 确保你的后台Goroutine在不再需要时总有办法退出（通常通过监听 `ctx.Done()` 或一个专门的退出Channel）。
    - 使用 `defer` 来确保资源（如锁、连接）一定会被释放。

5. **理解锁的粒度**：如果使用锁，要锁的是**保护一个独立数据单元所需的最小代码段**。持有锁期间不要做阻塞I/O操作。

6. **测试！测试！测试！**：使用 `go test -race` **始终开启竞态检测**来运行单元测试和集成测试。竞态检测器是发现并发问题最强大的工具。

## 总结：一个简单的设计清单

当你设计一个并发模块时，可以问自己以下问题：

- [ ] **状态是什么？** 我定义清楚了吗？
- [ ] **状态管理策略**我选对了吗？（首选Channel）
- [ ] **API是线程安全的吗？** 调用者是否能不加思考地并发调用？
- [ ] **生命周期管理**我做好了吗？（`Start`/`Shutdown`）
- [ ] **我如何观测**这个模块的运行状态？（Metrics, Tracing）
- [ ] **我如何测试**并发场景？（Race detector）

遵循这些步骤和注意事项，你将能系统地设计出更健壮、更安全、更易于维护的并发模块。
