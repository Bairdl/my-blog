# 通用模块设计方法

四个步骤：定义 -> 分解 -> 隔离 -> 连接。

## 定义

**弄清“做什么”，而非“怎么做”。**

目标：弄清模块的职责、输入和输出。

询问：

1. 核心职责：
   1. 模块存在的理由是什么？
   2. 简单描述模块的功能，避免繁琐。
2. 契约/接口
   1. 如何与外界交互——定义函数签名
   2. 需要什么——输入参数、依赖项。
   3. 提供什么——返回值、输入数据、副作用。
   4. **只定义接口和函数签名，而不考虑内部实现。**
3. 错误边界
   1. 什么情况下会失败？
   2. 会抛出哪些类型的异常或者错误？
   3. 调用者如何应对这些错误？

清晰的、注释良好的接口文档或者代码中的接口定义。

## 分解

**将复杂流程拆分为子步骤。**

目标：将第一步定义的单一职责，分解为一系列更小、更具体的子任务。

方法：

1. 时序分解：按事件发生的流程（业务流程）分解。
2. 功能分解：识别出流程中独立的功能点。

如何判断分解是否合理？

- 子模块的职责应该比父模块更具体、更单一。
- 子模块是否可以使用准确的动词短语来命名。

一个内部流程图或者一系列更小的、待实现的子模块接口。

## 隔离

**实现“高内聚，低耦合”。**

让每个模块聚焦于自己的任务，少使用其他模块的功能。

方法：

1. 依赖接口而非具体实现。
2. 控制副作用：
   1. 将读写数据库、调用API、发送消息等副作用操作与纯计算逻辑（如数据转换、验证、算法）分离开。
   2. 纯函数：给定相同输入、永远得到相同输出，没有任何副作用。
   3. 将副作用推到模块的边界（如最外层的控制器、命令行 handle），核心业务逻辑只处理数据。
3. immutable思想
   1. 尽可能使用不可变数据（如Go中的函数参数传值、const等）。一个数据一旦创建就不能被修改，只能被复制和衍生。

一系列实现具体功能的、相互隔离的、通过接口通信的模块。

## 连接

**组装各模块。**

将第三步实现好的模块按照第二步的流程图组装起来。

方法：

1. 依赖注入：
   1. 不要在模块内部 new 它的依赖，而是由外部创建好所有依赖，然后通过构造函数参数传递给模块。

## 并发考虑

主要在第三步（隔离）中使用技巧来写出并发友好的代码。

1. 无状态化：模块内部不保存任何可变状态。所有需要的数据都通过参数传递。
2. 局部化：如果必须要有状态（如缓存），则使用互斥锁（Mutex）、通道（Channel）等同步原语将状态严格封装中模块内部。
3. 通信顺序进程 (CSP)：Go 语言倡导的哲学：“不要通过共享内存来通信，而应通过通信来共享内存 (Do not communicate by sharing memory; instead, share memory by communicating)”。使用 Channel 在 goroutine 之间传递数据所有权，比使用 Mutex 保护共享内存更清晰。
