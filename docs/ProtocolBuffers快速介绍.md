
# Protocol Buffers

Protocol Buffers (简称 Protobuf) 是一种由 Google 开发的 **语言中立、平台中立、可扩展** 的结构化数据序列机制。

可以简单地将 protobuf 理解魏一个用于高效序列化和反序列化结构化数据的工具和规范。

## Protocol Buffers 组成

1. 接口定义语言 （IDL）
需要在一个 `.proto` 文件中定义数据结构（即结构化数据的存储格式）。

2. 编译器 （protoc）
编译器会根据编写的 `.proto` 文件，自动生成所选择的编程语言（如 C++、Java、Go 等）的代码。  
这些生成的类会提供操作结构化数（如访问字段、序列化/反序列化）的简单接口。

3. 运行时库
生成的代码需要依赖特定语言的 Protobuf 运行时库才能工作，这些库提供了基础的编码和解码实现。

简单来说，Protobuf 允许开发者自定义结构化数据（ `.proto` 文件），然后自动生成操作数据化结构的代码，让开发者可以轻松地将内存中的复杂数据结构转换可传输的二进字节流，或者将字节流反向转换回数据结构。

## 提出背景

Protobuf 于 2001 年左右在Google内部开始开发，最开始是为了解决Google在构建大规模、分布式系统（如搜索引擎、Gmail、Google Maps等）时面临的数据交换需求：

1. 性能瓶颈：在分布式系统中，不同的服务节点之前需要频繁地进行数据通信。使用 XML 作为主要的数据交换格式虽然人类可读，但是冗长（体积大）和解析复杂（耗时）的特征会严重影响系统性能和吞吐量。
2. 需要高效的序列化方案：Google 需要一种比XML更小、更快、更简单的序列化方案，以减少网络带宽占用和CPU计算时间，从而支撑其海量的服务请求。
3. 跨语言和跨平台：Google 内部使用多种编程语言，需要一种方案能无缝地在这些不同语言编写的服务之间进行数据交换。
4. 向前和向后兼容性：新的数据格式必需兼容旧版本，旧代码要能够忽略新增加的字段。

## 高效的序列化和反序列化

Protobuf 的高效性来源于其多种设计选择。其核心思想是“用计算换带宽”和“简化解析复杂度”。

1. 紧凑的二进制编码  
Protobuf的二进制流中不包含字段名、分隔符等元数据，使得编码后的数据体积非常小。  
标签号替代字段名，使用唯一数字标签减少字节占用。

2. 编码和解码流程简单  
解析Protobuf二进制流基本上是一个线性的过程。解码器读取一个（Tag、Length、Value）的组合，根据Tag中的数字找到对应的字段类型，然后根据类型从Value中解析出值。然后继续读取下一个组合。  
生成的代码提供了近乎直接的内存访问。反序列化时，解码器可以简单地将二进制值直接填充到预先生成好的类/结构体的对应字段中，避免了复杂的解释过程。

3. 预生成代码（AOT编译）
在应用开发阶段， `proto` 编译器就已经根据 `.proto` schema 生成了高度优化、针对特定语言序列化/反序列化代码。这是一种提前编译（AOT）。
